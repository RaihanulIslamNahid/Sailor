(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.TweakpaneMediaPlugin = {}));
})(this, (function (exports) { 'use strict';

    function forceCast(v) {
        return v;
    }

    const PREFIX = 'tp';
    function ClassName(viewName) {
        const fn = (opt_elementName, opt_modifier) => {
            return [
                PREFIX,
                '-',
                viewName,
                'v',
                opt_elementName ? `_${opt_elementName}` : '',
                opt_modifier ? `-${opt_modifier}` : '',
            ].join('');
        };
        return fn;
    }

    function parseObject(value, keyToParserMap) {
        const keys = Object.keys(keyToParserMap);
        const result = keys.reduce((tmp, key) => {
            if (tmp === undefined) {
                return undefined;
            }
            const parser = keyToParserMap[key];
            const result = parser(value[key]);
            return result.succeeded
                ? Object.assign(Object.assign({}, tmp), { [key]: result.value }) : undefined;
        }, {});
        return forceCast(result);
    }
    function parseArray(value, parseItem) {
        return value.reduce((tmp, item) => {
            if (tmp === undefined) {
                return undefined;
            }
            const result = parseItem(item);
            if (!result.succeeded || result.value === undefined) {
                return undefined;
            }
            return [...tmp, result.value];
        }, []);
    }
    function isObject(value) {
        if (value === null) {
            return false;
        }
        return typeof value === 'object';
    }
    function createParamsParserBuilder(parse) {
        return (optional) => (v) => {
            if (!optional && v === undefined) {
                return {
                    succeeded: false,
                    value: undefined,
                };
            }
            if (optional && v === undefined) {
                return {
                    succeeded: true,
                    value: undefined,
                };
            }
            const result = parse(v);
            return result !== undefined
                ? {
                    succeeded: true,
                    value: result,
                }
                : {
                    succeeded: false,
                    value: undefined,
                };
        };
    }
    function createParamsParserBuilders(optional) {
        return {
            custom: (parse) => createParamsParserBuilder(parse)(optional),
            boolean: createParamsParserBuilder((v) => typeof v === 'boolean' ? v : undefined)(optional),
            number: createParamsParserBuilder((v) => typeof v === 'number' ? v : undefined)(optional),
            string: createParamsParserBuilder((v) => typeof v === 'string' ? v : undefined)(optional),
            function: createParamsParserBuilder((v) =>
            typeof v === 'function' ? v : undefined)(optional),
            constant: (value) => createParamsParserBuilder((v) => (v === value ? value : undefined))(optional),
            raw: createParamsParserBuilder((v) => v)(optional),
            object: (keyToParserMap) => createParamsParserBuilder((v) => {
                if (!isObject(v)) {
                    return undefined;
                }
                return parseObject(v, keyToParserMap);
            })(optional),
            array: (itemParser) => createParamsParserBuilder((v) => {
                if (!Array.isArray(v)) {
                    return undefined;
                }
                return parseArray(v, itemParser);
            })(optional),
        };
    }
    const ParamsParsers = {
        optional: createParamsParserBuilders(true),
        required: createParamsParserBuilders(false),
    };
    function parseParams(value, keyToParserMap) {
        const result = ParamsParsers.required.object(keyToParserMap)(value);
        return result.succeeded ? result.value : undefined;
    }

    function createNumberFormatter(digits) {
        return (value) => {
            return value.toFixed(Math.max(Math.min(digits, 20), 0));
        };
    }

    const innerFormatter = createNumberFormatter(0);
    function formatPercentage(value) {
        return innerFormatter(value) + '%';
    }

    function constrainRange(value, min, max) {
        return Math.min(Math.max(value, min), max);
    }

    function removeAlphaComponent(comps) {
        return [comps[0], comps[1], comps[2]];
    }

    function zerofill(comp) {
        const hex = constrainRange(Math.floor(comp), 0, 255).toString(16);
        return hex.length === 1 ? `0${hex}` : hex;
    }
    function colorToHexRgbString(value, prefix = '#') {
        const hexes = removeAlphaComponent(value.getComponents('rgb'))
            .map(zerofill)
            .join('');
        return `${prefix}${hexes}`;
    }
    function colorToHexRgbaString(value, prefix = '#') {
        const rgbaComps = value.getComponents('rgb');
        const hexes = [rgbaComps[0], rgbaComps[1], rgbaComps[2], rgbaComps[3] * 255]
            .map(zerofill)
            .join('');
        return `${prefix}${hexes}`;
    }
    function colorToFunctionalRgbString(value, opt_type) {
        const formatter = createNumberFormatter(opt_type === 'float' ? 2 : 0);
        const comps = removeAlphaComponent(value.getComponents('rgb', opt_type)).map((comp) => formatter(comp));
        return `rgb(${comps.join(', ')})`;
    }
    function createFunctionalRgbColorFormatter(type) {
        return (value) => {
            return colorToFunctionalRgbString(value, type);
        };
    }
    function colorToFunctionalRgbaString(value, opt_type) {
        const aFormatter = createNumberFormatter(2);
        const rgbFormatter = createNumberFormatter(opt_type === 'float' ? 2 : 0);
        const comps = value.getComponents('rgb', opt_type).map((comp, index) => {
            const formatter = index === 3 ? aFormatter : rgbFormatter;
            return formatter(comp);
        });
        return `rgba(${comps.join(', ')})`;
    }
    function createFunctionalRgbaColorFormatter(type) {
        return (value) => {
            return colorToFunctionalRgbaString(value, type);
        };
    }
    function colorToFunctionalHslString(value) {
        const formatters = [
            createNumberFormatter(0),
            formatPercentage,
            formatPercentage,
        ];
        const comps = removeAlphaComponent(value.getComponents('hsl')).map((comp, index) => formatters[index](comp));
        return `hsl(${comps.join(', ')})`;
    }
    function colorToFunctionalHslaString(value) {
        const formatters = [
            createNumberFormatter(0),
            formatPercentage,
            formatPercentage,
            createNumberFormatter(2),
        ];
        const comps = value
            .getComponents('hsl')
            .map((comp, index) => formatters[index](comp));
        return `hsla(${comps.join(', ')})`;
    }
    function colorToObjectRgbString(value, type) {
        const formatter = createNumberFormatter(type === 'float' ? 2 : 0);
        const names = ['r', 'g', 'b'];
        const comps = removeAlphaComponent(value.getComponents('rgb', type)).map((comp, index) => `${names[index]}: ${formatter(comp)}`);
        return `{${comps.join(', ')}}`;
    }
    function createObjectRgbColorFormatter(type) {
        return (value) => colorToObjectRgbString(value, type);
    }
    function colorToObjectRgbaString(value, type) {
        const aFormatter = createNumberFormatter(2);
        const rgbFormatter = createNumberFormatter(type === 'float' ? 2 : 0);
        const names = ['r', 'g', 'b', 'a'];
        const comps = value.getComponents('rgb', type).map((comp, index) => {
            const formatter = index === 3 ? aFormatter : rgbFormatter;
            return `${names[index]}: ${formatter(comp)}`;
        });
        return `{${comps.join(', ')}}`;
    }
    function createObjectRgbaColorFormatter(type) {
        return (value) => colorToObjectRgbaString(value, type);
    }
    [
        {
            format: {
                alpha: false,
                mode: 'rgb',
                notation: 'hex',
                type: 'int',
            },
            stringifier: colorToHexRgbString,
        },
        {
            format: {
                alpha: true,
                mode: 'rgb',
                notation: 'hex',
                type: 'int',
            },
            stringifier: colorToHexRgbaString,
        },
        {
            format: {
                alpha: false,
                mode: 'hsl',
                notation: 'func',
                type: 'int',
            },
            stringifier: colorToFunctionalHslString,
        },
        {
            format: {
                alpha: true,
                mode: 'hsl',
                notation: 'func',
                type: 'int',
            },
            stringifier: colorToFunctionalHslaString,
        },
        ...['int', 'float'].reduce((prev, type) => {
            return [
                ...prev,
                {
                    format: {
                        alpha: false,
                        mode: 'rgb',
                        notation: 'func',
                        type: type,
                    },
                    stringifier: createFunctionalRgbColorFormatter(type),
                },
                {
                    format: {
                        alpha: true,
                        mode: 'rgb',
                        notation: 'func',
                        type: type,
                    },
                    stringifier: createFunctionalRgbaColorFormatter(type),
                },
                {
                    format: {
                        alpha: false,
                        mode: 'rgb',
                        notation: 'object',
                        type: type,
                    },
                    stringifier: createObjectRgbColorFormatter(type),
                },
                {
                    format: {
                        alpha: true,
                        mode: 'rgb',
                        notation: 'object',
                        type: type,
                    },
                    stringifier: createObjectRgbaColorFormatter(type),
                },
            ];
        }, []),
    ];

    // Create a class name generator from the view name
    // ClassName('tmp') will generate a CSS class name like `tp-tmpv`
    const className$1 = ClassName('tmp');
    // Custom view class should implement `View` interface
    class PluginView$1 {
        constructor(doc, config) {
            // Params
            this.params_ = config.params;
            // Receive the bound value from the controller
            this.value_ = config.value;
            // Init id for monitor
            this.value_.rawValue.id = this.value_.rawValue.src;
            // Extensions
            this.extensions_ = this.params_.extensions || '.jpg, .jpeg, .png, .webp, .avif';
            // Create a root element for the plugin
            this.element = this.createElement_(doc);
            // Bind view props to the element
            config.viewProps.bindClassModifiers(this.element);
            // Header
            this.head_ = this.createHead_(doc);
            this.element.appendChild(this.head_);
            this.monitor_ = this.createMonitor_(doc);
            this.head_.appendChild(this.monitor_);
            // Container
            this.container_ = this.createContainer_(doc);
            this.element.appendChild(this.container_);
            // Input
            this.input = this.createInput_(doc);
            this.container_.appendChild(this.input);
            // Label
            this.label_ = this.createLabel_(doc);
            this.container_.appendChild(this.label_);
            // Image
            this.image_ = this.createImage_();
            this.container_.appendChild(this.image_);
            // Bind
            this.bindAll_();
            // Events
            this.setupEventListeners_();
            // Apply the initial value
            this.refresh_();
            // Dispose
            config.viewProps.handleDispose(() => {
                this.removeEventListeners_();
            });
        }
        refresh_() {
            // Show Image in monitor
            this.image_.setAttribute('src', this.value_.rawValue.src);
            // Reset opacity
            if (this.value_.rawValue.src) {
                this.image_.style.opacity = '1';
                this.label_.style.opacity = '0';
            }
            else {
                this.label_.style.opacity = '1';
            }
            // Apply image id
            this.monitor_.innerHTML = this.value_.rawValue.id;
            // Display monitor
            if (this.value_.rawValue.id && this.params_.showMonitor) {
                this.head_.style.display = 'flex';
            }
        }
        createElement_(doc) {
            const element = doc.createElement('div');
            element.classList.add(className$1());
            element.style.position = 'relative';
            element.style.height = `${this.params_.height || 100}px`;
            return element;
        }
        createContainer_(doc) {
            const container = doc.createElement('div');
            container.classList.add(className$1('container'));
            container.style.height = `${this.params_.height || 100}px`;
            return container;
        }
        createHead_(doc) {
            const head = doc.createElement('div');
            head.classList.add(className$1('head'));
            if (this.value_.rawValue.id && this.params_.showMonitor)
                head.style.display = 'flex';
            return head;
        }
        createMonitor_(doc) {
            const monitor = doc.createElement('div');
            monitor.classList.add(className$1('monitor'));
            monitor.innerHTML = this.value_.rawValue.id;
            return monitor;
        }
        createInput_(doc) {
            const input = doc.createElement('input');
            input.classList.add(className$1('input'));
            input.setAttribute('id', 'image');
            input.setAttribute('type', 'file');
            input.setAttribute('accept', this.extensions_);
            return input;
        }
        createLabel_(doc) {
            const label = doc.createElement('label');
            label.setAttribute('for', 'image');
            label.classList.add(className$1('label'));
            label.innerHTML = '<span>Import image</span>';
            return label;
        }
        createImage_() {
            const image = new Image();
            image.style.position = 'absolute';
            image.style.pointerEvents = 'none';
            image.style.left = '0';
            image.style.top = '0';
            image.style.width = '100%';
            image.style.height = '100%';
            image.style.objectFit = this.params_.objectFit || 'cover';
            return image;
        }
        bindAll_() {
            this.valueChangedHandler_ = this.valueChangedHandler_.bind(this);
            this.dragenterHandler_ = this.dragenterHandler_.bind(this);
            this.dragleaveHandler_ = this.dragleaveHandler_.bind(this);
            this.mouseenterHandler_ = this.mouseenterHandler_.bind(this);
            this.mouseleaveHandler_ = this.mouseleaveHandler_.bind(this);
        }
        setupEventListeners_() {
            this.value_.emitter.on('change', this.valueChangedHandler_);
            this.input.addEventListener('dragenter', this.dragenterHandler_);
            this.input.addEventListener('dragleave', this.dragleaveHandler_);
            this.input.addEventListener('mouseenter', this.mouseenterHandler_);
            this.input.addEventListener('mouseleave', this.mouseleaveHandler_);
        }
        removeEventListeners_() {
            this.value_.emitter.off('change', this.valueChangedHandler_.bind(this));
            this.input.removeEventListener('dragenter', this.dragenterHandler_);
            this.input.removeEventListener('dragleave', this.dragleaveHandler_);
            this.input.removeEventListener('mouseenter', this.mouseenterHandler_);
            this.input.removeEventListener('mouseleave', this.mouseleaveHandler_);
        }
        valueChangedHandler_() {
            this.refresh_();
        }
        dragenterHandler_(event) {
            if (event.dataTransfer &&
                event.dataTransfer.items[0] &&
                event.dataTransfer.items[0].type.includes('image')) {
                this.image_.style.opacity = '0';
                this.label_.style.opacity = '1';
            }
        }
        dragleaveHandler_() {
            if (this.value_.rawValue.src) {
                this.image_.style.opacity = '1';
                this.label_.style.opacity = '0';
            }
        }
        mouseenterHandler_() {
            this.container_.style.opacity = '0.5';
        }
        mouseleaveHandler_() {
            this.container_.style.opacity = '1';
        }
    }

    // Custom controller class should implement `Controller` interface
    class PluginController$1 {
        constructor(doc, config) {
            // Receive the bound value from the plugin
            this.value = config.value;
            this.params = config.params;
            // and also view props
            this.viewProps = config.viewProps;
            this.viewProps.handleDispose(() => {
                this.removeEventListeners_();
            });
            // Create a custom view
            this.view = new PluginView$1(doc, {
                value: this.value,
                viewProps: this.viewProps,
                params: this.params,
            });
            // Bind
            this.bindAll_();
            // Events
            this.setupEventListeners_();
        }
        bindAll_() {
            this.inputHandler_ = this.inputHandler_.bind(this);
        }
        setupEventListeners_() {
            this.view.input.addEventListener('input', this.inputHandler_);
        }
        removeEventListeners_() {
            this.view.input.removeEventListener('input', this.inputHandler_);
        }
        inputHandler_() {
            const file = this.view.input.files ? this.view.input.files[0] : null;
            if (!file)
                return;
            const image = new Image();
            image.src = URL.createObjectURL(file);
            image.id = file.name;
            const loadHandler = () => {
                image.removeEventListener('load', loadHandler);
                this.value.rawValue = image;
            };
            image.addEventListener('load', loadHandler);
        }
    }

    // NOTE: You can see JSDoc comments of `InputBindingPlugin` for details about each property
    //
    // `InputBindingPlugin<In, Ex, P>` means...
    // - The plugin receives the bound value as `Ex`,
    // - converts `Ex` into `In` and holds it
    // - P is the type of the parsed parameters
    //
    const PluginImageInput = {
        id: 'image-input',
        type: 'input',
        css: '.tp-tmpv{display:flex;flex-direction:column;overflow:hidden;position:relative;background-color:var(--bs-bg)}.tp-tmpv.tp-v-disabled{opacity:.5}.tp-tmpv_label{display:flex;justify-content:center;align-items:center;position:absolute;left:0;top:0;bottom:0;right:0;margin:auto;text-align:center;width:100%;pointer-events:none;color:var(--in-fg);font-size:.9em;line-height:.9;opacity:.5}.tp-tmpv_container{position:relative;background-color:var(--in-bg);border-radius:var(--elm-br);overflow:hidden}.tp-tmpv_head{display:none;align-items:center;width:100%;height:2em;margin-bottom:4px;background-color:var(--in-bg-a);border-radius:var(--elm-br);white-space:nowrap}.tp-tmpv_monitor{margin-top:1px;font-size:.9em;line-height:.9;opacity:.5;padding-left:4px;color:var(--in-fg)}.tp-tmpv_input{position:absolute;left:0;top:0;width:100%;height:100%;opacity:0;padding:0;cursor:pointer}.tp-tmpv input::-webkit-file-upload-button{display:none}',
        accept(exValue, params) {
            // Return null if underfined
            if (!exValue)
                return null;
            // Return null if not HTML Element
            if (!(exValue instanceof HTMLImageElement))
                return null;
            // Parse parameters object
            const result = parseParams(params, {
                // `view` option may be useful to provide a custom control for primitive values
                extensions: ParamsParsers.optional.string,
                objectFit: ParamsParsers.optional.string,
                height: ParamsParsers.optional.number,
                showMonitor: ParamsParsers.optional.boolean,
                label: ParamsParsers.required.string,
                view: ParamsParsers.required.constant('image'),
            });
            if (!result) {
                return null;
            }
            // Return a typed value and params to accept the user input
            return {
                initialValue: exValue,
                params: result,
            };
        },
        binding: {
            reader(_args) {
                return (exValue) => {
                    return exValue instanceof HTMLImageElement ? exValue : new Image();
                };
            },
            writer(_args) {
                return (target, inValue) => {
                    // Use `target.write()` to write the primitive value to the target,
                    // or `target.writeProperty()` to write a property of the target
                    target.write(inValue);
                };
            },
        },
        controller(args) {
            // Create a controller for the plugin
            return new PluginController$1(args.document, {
                value: args.value,
                viewProps: args.viewProps,
                params: args.params,
            });
        },
    };

    // Create a class name generator from the view name
    // ClassName('tmp') will generate a CSS class name like `tp-tmpv`
    const className = ClassName('tmp');
    // Custom view class should implement `View` interface
    class PluginView {
        constructor(doc, config) {
            // Params
            this.params_ = config.params;
            // Receive the bound value from the controller
            this.value_ = config.value;
            // Init id for monitor
            this.value_.rawValue.id = this.value_.rawValue.src;
            // Extensions
            this.extensions_ =
                this.params_.extensions || '.mp4, .mov, .mpeg, .ogg, .webm, .mkv, .avi';
            // Create a root element for the plugin
            this.element = this.createElement_(doc);
            // Bind view props to the element
            config.viewProps.bindClassModifiers(this.element);
            // Header
            this.head_ = this.createHead_(doc);
            this.element.appendChild(this.head_);
            this.monitor_ = this.createMonitor_(doc);
            this.head_.appendChild(this.monitor_);
            // Container
            this.container_ = this.createContainer_(doc);
            this.element.appendChild(this.container_);
            // Input
            this.input = this.createInput_(doc);
            this.container_.appendChild(this.input);
            // Label
            this.label_ = this.createLabel_(doc);
            this.container_.appendChild(this.label_);
            // Image
            this.video_ = this.createVideo_(doc);
            this.container_.appendChild(this.video_);
            // Bind
            this.bindAll_();
            // Events
            this.setupEventListeners_();
            // Apply the initial value
            this.refresh_();
            // Dispose
            config.viewProps.handleDispose(() => {
                this.removeEventListeners_();
            });
        }
        refresh_() {
            // Show Image in monitor
            this.video_.setAttribute('src', this.value_.rawValue.src);
            // Reset opacity
            if (this.value_.rawValue.src) {
                this.video_.style.opacity = '1';
                this.label_.style.opacity = '0';
            }
            else {
                this.label_.style.opacity = '1';
            }
            // Apply image id
            this.monitor_.innerHTML = this.value_.rawValue.id;
            // Display monitor
            if (this.value_.rawValue.id && this.params_.showMonitor) {
                this.head_.style.display = 'flex';
            }
        }
        createElement_(doc) {
            const element = doc.createElement('div');
            element.classList.add(className());
            element.style.position = 'relative';
            if (this.params_.height)
                element.style.height = `${this.params_.height}px`;
            return element;
        }
        createContainer_(doc) {
            const container = doc.createElement('div');
            container.classList.add(className('container'));
            if (this.params_.height)
                container.style.height = `${this.params_.height}px`;
            return container;
        }
        createHead_(doc) {
            const head = doc.createElement('div');
            head.classList.add(className('head'));
            if (this.value_.rawValue.id && this.params_.showMonitor)
                head.style.display = 'flex';
            return head;
        }
        createMonitor_(doc) {
            const monitor = doc.createElement('div');
            monitor.classList.add(className('monitor'));
            monitor.innerHTML = this.value_.rawValue.id;
            return monitor;
        }
        createInput_(doc) {
            const input = doc.createElement('input');
            input.classList.add(className('input'));
            input.setAttribute('id', 'image');
            input.setAttribute('type', 'file');
            input.setAttribute('accept', this.extensions_);
            return input;
        }
        createLabel_(doc) {
            const label = doc.createElement('label');
            label.setAttribute('for', 'image');
            label.classList.add(className('label'));
            label.innerHTML = '<span>Import video</span>';
            return label;
        }
        createVideo_(doc) {
            const video = doc.createElement('video');
            video.setAttribute('muted', 'true');
            video.setAttribute('playsinline', 'true');
            video.setAttribute('autoplay', 'true');
            video.setAttribute('loop', 'true');
            video.style.opacity = '0';
            video.style.position = 'absolute';
            video.style.pointerEvents = 'none';
            video.style.left = '0';
            video.style.top = '0';
            video.style.width = '100%';
            video.style.height = '100%';
            video.style.objectFit = 'cover';
            video.style.objectFit = this.params_.objectFit || 'cover';
            return video;
        }
        bindAll_() {
            this.valueChangedHandler_ = this.valueChangedHandler_.bind(this);
            this.dragenterHandler_ = this.dragenterHandler_.bind(this);
            this.dragleaveHandler_ = this.dragleaveHandler_.bind(this);
            this.mouseenterHandler_ = this.mouseenterHandler_.bind(this);
            this.mouseleaveHandler_ = this.mouseleaveHandler_.bind(this);
        }
        setupEventListeners_() {
            this.value_.emitter.on('change', this.valueChangedHandler_);
            this.input.addEventListener('dragenter', this.dragenterHandler_);
            this.input.addEventListener('dragleave', this.dragleaveHandler_);
            this.input.addEventListener('mouseenter', this.mouseenterHandler_);
            this.input.addEventListener('mouseleave', this.mouseleaveHandler_);
        }
        removeEventListeners_() {
            this.value_.emitter.off('change', this.valueChangedHandler_.bind(this));
            this.input.removeEventListener('dragenter', this.dragenterHandler_);
            this.input.removeEventListener('dragleave', this.dragleaveHandler_);
            this.input.removeEventListener('mouseenter', this.mouseenterHandler_);
            this.input.removeEventListener('mouseleave', this.mouseleaveHandler_);
        }
        valueChangedHandler_() {
            this.refresh_();
        }
        dragenterHandler_(event) {
            if (event.dataTransfer &&
                event.dataTransfer.items[0] &&
                event.dataTransfer.items[0].type.includes('video')) {
                this.video_.style.opacity = '0';
                this.label_.style.opacity = '1';
            }
        }
        dragleaveHandler_() {
            if (this.value_.rawValue.src) {
                this.video_.style.opacity = '1';
                this.label_.style.opacity = '0';
            }
        }
        mouseenterHandler_() {
            this.container_.style.opacity = '0.5';
        }
        mouseleaveHandler_() {
            this.container_.style.opacity = '1';
        }
    }

    // Custom controller class should implement `Controller` interface
    class PluginController {
        constructor(doc, config) {
            // Receive the bound value from the plugin
            this.value = config.value;
            this.params = config.params;
            // and also view props
            this.viewProps = config.viewProps;
            this.viewProps.handleDispose(() => {
                this.removeEventListeners_();
            });
            // Create a custom view
            this.view = new PluginView(doc, {
                value: this.value,
                viewProps: this.viewProps,
                params: this.params,
            });
            // Bind
            this.bindAll_();
            // Events
            this.setupEventListeners_();
        }
        bindAll_() {
            this.inputHandler_ = this.inputHandler_.bind(this);
        }
        setupEventListeners_() {
            this.view.input.addEventListener('input', this.inputHandler_);
        }
        removeEventListeners_() {
            this.view.input.removeEventListener('input', this.inputHandler_);
        }
        inputHandler_() {
            const file = this.view.input.files ? this.view.input.files[0] : null;
            if (!file)
                return;
            const video = document.createElement('video');
            video.src = URL.createObjectURL(file);
            video.id = file.name;
            const loadHandler = () => {
                video.removeEventListener('canplay', loadHandler);
                this.value.rawValue = video;
            };
            video.addEventListener('canplay', loadHandler);
        }
    }

    // NOTE: You can see JSDoc comments of `InputBindingPlugin` for details about each property
    //
    // `InputBindingPlugin<In, Ex, P>` means...
    // - The plugin receives the bound value as `Ex`,
    // - converts `Ex` into `In` and holds it
    // - P is the type of the parsed parameters
    //
    const PluginVideoInput = {
        id: 'video-input',
        type: 'input',
        css: '.tp-tmpv{display:flex;flex-direction:column;overflow:hidden;position:relative;background-color:var(--bs-bg)}.tp-tmpv.tp-v-disabled{opacity:.5}.tp-tmpv_label{display:flex;justify-content:center;align-items:center;position:absolute;left:0;top:0;bottom:0;right:0;margin:auto;text-align:center;width:100%;pointer-events:none;color:var(--in-fg);font-size:.9em;line-height:.9;opacity:.5}.tp-tmpv_container{position:relative;background-color:var(--in-bg);border-radius:var(--elm-br);overflow:hidden}.tp-tmpv_head{display:none;align-items:center;width:100%;height:2em;margin-bottom:4px;background-color:var(--in-bg-a);border-radius:var(--elm-br);white-space:nowrap}.tp-tmpv_monitor{margin-top:1px;font-size:.9em;line-height:.9;opacity:.5;padding-left:4px;color:var(--in-fg)}.tp-tmpv_input{position:absolute;left:0;top:0;width:100%;height:100%;opacity:0;padding:0;cursor:pointer}.tp-tmpv input::-webkit-file-upload-button{display:none}',
        accept(exValue, params) {
            // Return null if underfined
            if (!exValue)
                return null;
            // Return null if not HTML Element
            if (!(exValue instanceof HTMLVideoElement))
                return null;
            // Parse parameters object
            const result = parseParams(params, {
                // `view` option may be useful to provide a custom control for primitive values
                extensions: ParamsParsers.optional.string,
                objectFit: ParamsParsers.optional.string,
                height: ParamsParsers.optional.number,
                showMonitor: ParamsParsers.optional.boolean,
                label: ParamsParsers.required.string,
                view: ParamsParsers.required.constant('video'),
            });
            if (!result) {
                return null;
            }
            // Return a typed value and params to accept the user input
            return {
                initialValue: exValue,
                params: result,
            };
        },
        binding: {
            reader(_args) {
                return (exValue) => {
                    return exValue instanceof HTMLVideoElement
                        ? exValue
                        : document.createElement('video');
                };
            },
            writer(_args) {
                return (target, inValue) => {
                    // Use `target.write()` to write the primitive value to the target,
                    // or `target.writeProperty()` to write a property of the target
                    target.write(inValue);
                };
            },
        },
        controller(args) {
            // Create a controller for the plugin
            return new PluginController(args.document, {
                value: args.value,
                viewProps: args.viewProps,
                params: args.params,
            });
        },
    };

    // Export your plugin(s) as constant `plugins`
    const plugins = [PluginImageInput, PluginVideoInput];

    exports.plugins = plugins;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
